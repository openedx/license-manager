"""
Integration level tests for expected events that should be generated by the
usage of the Subscription and License V1 API view set

"""
import logging
from unittest import mock

import ddt
from django.http import QueryDict
from django.test import TestCase
from django.urls import reverse
from freezegun import freeze_time
from rest_framework import status

from license_manager.apps.api import tasks
from license_manager.apps.api.v1.tests.test_views import (
    LicenseViewSetActionMixin,
    LicenseViewTestMixin,
)
from license_manager.apps.subscriptions import api, constants, utils
from license_manager.apps.subscriptions.tests.factories import (
    LicenseFactory,
    SubscriptionPlanFactory,
    SubscriptionPlanRenewalFactory,
)


logger = logging.getLogger(__name__)

NOW = utils.localized_utcnow()


class EventTestCaseBase(TestCase):
    """
    Mocks the call to ``track_license_changes_task.delay()``
    to just be a simple python invocation of ``track_license_changes()``.
    """
    def setUp(self):
        super().setUp()
        self.mock_track_license_changes_mocker = mock.patch(
            'license_manager.apps.api.v1.views.track_license_changes_task.delay',
            wraps=tasks.track_license_changes_task,
        )
        self.mock_track_license_changes_mocker.start()

    def tearDown(self):
        super().tearDown()
        self.mock_track_license_changes_mocker.stop()


@ddt.ddt
class LicenseViewSetActionEventTests(LicenseViewSetActionMixin, EventTestCaseBase):
    @classmethod
    def setUpTestData(cls):
        super().setUpTestData()

        # Routes setup
        cls.assign_url = reverse('api:v1:licenses-assign', kwargs={'subscription_uuid': cls.subscription_plan.uuid})

        cls.bulk_revoke_license_url = reverse(
            'api:v1:licenses-bulk-revoke',
            kwargs={'subscription_uuid': cls.subscription_plan.uuid},
        )

    def test_basic_bulk_create_event(self):
        """
        Basic test to make sure batch creates trigger create event.
        """
        # Mock the calls to track_event specifically imported in the models file.
        with mock.patch('license_manager.apps.subscriptions.models.track_event') as mock_track_event:
            num_licenses = 5
            LicenseFactory.create_batch(
                num_licenses,
                subscription_plan=self.subscription_plan,
                status=constants.UNASSIGNED,
            )
            assert mock_track_event.call_count == num_licenses
            for call in mock_track_event.call_args_list:
                # We should have events all called with the created event:
                assert call[0][1] == constants.SegmentEvents.LICENSE_CREATED

    @mock.patch('license_manager.apps.api.v1.views.link_learners_to_enterprise_task.si')
    @mock.patch('license_manager.apps.api.v1.views.send_assignment_email_task.si')
    def test_assign_dedupe_eventing(self, _, __):
        """
        Verify the assign endpoint deduplicates submitted emails.
        """
        self._create_available_licenses()
        user_emails = [self.test_email, self.test_email]

        with mock.patch('license_manager.apps.subscriptions.event_utils.track_event') as mock_assign_track_event:
            response = self.api_client.post(
                self.assign_url,
                {'greeting': self.greeting, 'closing': self.closing, 'user_emails': user_emails},
            )
            # We should only have fired an event for 1 assignment:
            assert mock_assign_track_event.call_count == 1
            for call in mock_assign_track_event.call_args_list:
                assert call[0][1] == constants.SegmentEvents.LICENSE_ASSIGNED
            assert response.status_code == status.HTTP_200_OK
            self._assert_licenses_assigned([self.test_email])

    @ddt.data(True, False)
    @mock.patch('license_manager.apps.api.v1.views.link_learners_to_enterprise_task.si')
    @mock.patch('license_manager.apps.api.v1.views.send_assignment_email_task.si')
    def test_assign_eventing(self, use_superuser, _, __):
        """ Verify that assignment events are generated by the view action."""
        # Mock the calls to track_event specifically imported in the models file.
        with mock.patch('license_manager.apps.subscriptions.models.track_event') as mock_create_track_event:
            self._setup_request_jwt(user=self.super_user if use_superuser else self.user)
            self._create_available_licenses(num_licenses=5)
            assert mock_create_track_event.call_count == 5
            for call in mock_create_track_event.call_args_list:
                assert call[0][1] == constants.SegmentEvents.LICENSE_CREATED

        with mock.patch('license_manager.apps.subscriptions.event_utils.track_event') as mock_assign_track_event:
            user_emails = ['bb8@mit.edu', self.test_email]
            response = self.api_client.post(
                self.assign_url,
                {'greeting': self.greeting, 'closing': self.closing, 'user_emails': user_emails},
            )
            assert response.status_code == status.HTTP_200_OK
            assert mock_assign_track_event.call_count == 2
            for call in mock_assign_track_event.call_args_list:
                assert call[0][1] == constants.SegmentEvents.LICENSE_ASSIGNED

    @mock.patch('license_manager.apps.api.v1.views.link_learners_to_enterprise_task.si')
    @mock.patch('license_manager.apps.api.v1.views.send_assignment_email_task.si')
    @mock.patch('license_manager.apps.api.tasks.revoke_course_enrollments_for_user_task.delay')
    @mock.patch('license_manager.apps.api.tasks.send_revocation_cap_notification_email_task.delay')
    def test_bulk_revoked_event(self, *_):
        """
        Test that bulk revoking licenses  triggers the right set of events:
        revoke event and creation of a fresh license
        the customer can now use as a replacement.
        """
        self._setup_request_jwt(user=self.user)
        alice_license = LicenseFactory.create(user_email='alice@example.com', status=constants.ACTIVATED)
        bob_license = LicenseFactory.create(user_email='bob@example.com', status=constants.ACTIVATED)
        self.subscription_plan.licenses.set([alice_license, bob_license])

        request_payload = {
            'user_emails': [
                'alice@example.com',
                'bob@example.com',
            ],
        }

        # Patch differently because the modules import track_event differently:
        with mock.patch('license_manager.apps.subscriptions.models.track_event') as mock_revoke_track_event, \
                mock.patch('license_manager.apps.subscriptions.event_utils.track_event') as mock_create_track_event:
            response = self.api_client.post(self.bulk_revoke_license_url, request_payload)
            assert response.status_code == status.HTTP_204_NO_CONTENT

            assert mock_revoke_track_event.call_count == 2
            assert mock_create_track_event.call_count == 2

            assert (mock_revoke_track_event.call_args_list[0][0][1]
                    == constants.SegmentEvents.LICENSE_REVOKED)
            assert (mock_revoke_track_event.call_args_list[0][0][2]['assigned_email']
                    == 'alice@example.com')
            assert (mock_create_track_event.call_args_list[0][0][1]
                    == constants.SegmentEvents.LICENSE_CREATED)
            assert mock_create_track_event.call_args_list[0][0][2]['assigned_email'] == ''

            assert (mock_revoke_track_event.call_args_list[1][0][1]
                    == constants.SegmentEvents.LICENSE_REVOKED)
            assert (mock_revoke_track_event.call_args_list[1][0][2]['assigned_email']
                    == 'bob@example.com')
            assert (mock_create_track_event.call_args_list[1][0][1]
                    == constants.SegmentEvents.LICENSE_CREATED)
            assert mock_create_track_event.call_args_list[1][0][2]['assigned_email'] == ''

    def test_license_renewed_events(self):
        """ Test that our standard renewal routine triggers the right set of events
        for all licenses involved:
            - a creation event for each new license
            - NO assignment or activation event since the license comes from a renewal.
            - a renewal event for each old/new license pair
        """
        prior_plan = SubscriptionPlanFactory()
        original_activated_licenses = [
            LicenseFactory.create(
                subscription_plan=prior_plan,
                status=constants.ACTIVATED,
                user_email='activated_user_{}@example.com'.format(i)
            ) for i in range(2)
        ]
        original_assigned_licenses = [
            LicenseFactory.create(
                subscription_plan=prior_plan,
                status=constants.ASSIGNED,
                user_email='assigned_user_{}@example.com'.format(i)
            ) for i in range(2)
        ]
        original_licenses = original_activated_licenses + original_assigned_licenses

        renewal = SubscriptionPlanRenewalFactory(
            prior_subscription_plan=prior_plan,
            number_of_licenses=len(original_licenses),
            license_types_to_copy=constants.LicenseTypesToRenew.ASSIGNED_AND_ACTIVATED
        )

        with mock.patch('license_manager.apps.subscriptions.event_utils.track_event') as mock_track_event:
            with freeze_time(NOW):
                api.renew_subscription(renewal)
            renewal.refresh_from_db()

            for call in mock_track_event.call_args_list[0:4]:
                assert call[0][1] == constants.SegmentEvents.LICENSE_CREATED

            for call in mock_track_event.call_args_list[4:]:
                assert call[0][1] == constants.SegmentEvents.LICENSE_RENEWED
            assert mock_track_event.call_count == 8

    def test_activate_event(self):
        pass


@ddt.ddt
class LicenseLearnerActionsEventTests(LicenseViewTestMixin, TestCase):
    @mock.patch('license_manager.apps.api.v1.views.send_post_activation_email_task.delay')
    def test_activate_an_assigned_license(self, _):
        self._assign_learner_roles(
            jwt_payload_extra={
                'user_id': self.lms_user_id,
                'email': self.user.email,
                'subscription_uuid': str(self.active_subscription_for_customer.uuid),
            }
        )
        license_to_be_activated = self._create_license()
        with mock.patch('license_manager.apps.subscriptions.event_utils.track_event') as mock_activated_track_event:

            with freeze_time(self.now):
                query_params = QueryDict(mutable=True)
                query_params['activation_key'] = str(self.activation_key)
                url = reverse('api:v1:license-activation') + '/?' + query_params.urlencode()
                response = self.api_client.post(url)

            assert status.HTTP_204_NO_CONTENT == response.status_code
            license_to_be_activated.refresh_from_db()

            assert mock_activated_track_event.call_count == 1

            assert (mock_activated_track_event.call_args_list[0][0][1]
                    == constants.SegmentEvents.LICENSE_ACTIVATED)
            assert mock_activated_track_event.call_args_list[0][0][2]['assigned_email'] == self.user.email
            assert mock_activated_track_event.call_args_list[0][0][2]['assigned_lms_user_id'] == self.lms_user_id
            assert (mock_activated_track_event.call_args_list[0][0][2]['activation_date']
                    == self.now.strftime('%Y-%m-%dT%H:%M:%SZ'))
